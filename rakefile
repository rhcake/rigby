require "rake/clean"


SWIG_WIN = "C:/swig/Lib/windows.i";
SWIG_MOD = "RigbyBridge";
SWIG_I = "#{SWIG_MOD}.i";
directory "gen/api/Rigby";
directory "gen/src";


API_H = FileList["inc/api/**/*.h"];
API_C = FileList["src/api/**/*.cpp"];
API_CS = FileList["api/**/*.cs"];
API_GEN = API_H.map { |f|
	f.ext("cs").sub(/^inc\/api\//, "gen/api/");
};


#Generate SWIG interface file
File.open(SWIG_I, "w") { |f|
	f.puts("%module #{SWIG_MOD}");
	f.puts("");
	f.puts("%{");
	API_H.each { |h|
		f.puts("#include <#{h.sub(/^inc\//, "")}>");
	};
	f.puts("%}");
	f.puts("");
	f.puts("%include <#{SWIG_WIN}>");
	f.puts("");
	API_H.each { |h|
		ns = h.sub(/^inc\/api\//, "");
		ns = File.dirname(ns);
		ns = ns.split("/");
		ns.shift();
		if (ns.length() > 0) then
			f.print("%nspace ");
			ns.each { |n|
				f.print("#{n}::");
			};
			f.puts("#{File.basename(h, File.extname(h))};");
			ns.each { |n|
				f.puts("namespace #{n} {");
			};
		end
		f.puts("%include \"#{h}\"");
		if (ns.length() > 0) then
			ns.each { |n|
				f.puts("}");
			};
		end
		f.puts("");
	};
}


SWIG_FLAGS = [
	"-c++",
	"-csharp",
	"-namespace Rigby",
	"-o gen/src/RigbyBridge_wrap.cpp",
	"-outdir gen/api/Rigby",
	"-dllimport __Internal"].join(" ");


rule /^gen\/api\/.+\.cs$/ => [ ->(f) {
	f.ext("h").sub(/^gen\/api\//, "inc/api/");
}, ->(f) {
	f.ext("cpp").sub(/^gen\/api\//, "src/api/");
}, "gen/api/Rigby", "gen/src"] do |f|
	puts("#{f.source} --> #{f.name}");
	sh "swig #{SWIG_FLAGS} #{SWIG_I}";
end


API_DLL = "bin/Rigby.dll";
directory "bin";


API_FLAGS = [
	"/target:library",
	"/out:#{API_DLL}",
	"/recurse:api/*.cs",
	"/recurse:gen/api/*.cs"].join(" ");


file API_DLL => API_CS + API_GEN + ["bin"] do
	sh "mcs #{API_FLAGS}";
end


task :default => API_DLL;


CLEAN.include("bin");
CLEAN.include("gen");